import requests
import os
import logging
import json
from datetime import datetime
from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    CallbackContext,
)

# Your API tokens
TELEGRAM_TOKEN = "8390570038:AAF2W6IsvXwLWnyrI0qkbtq-j7S6Laseczo"
GEMINI_API_KEY = "AIzaSyBsqJq-Bt3vPh7NvEYrsbV-DGdbveOxgxU"

# Setup logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)

# Global variables
KB_FOLDER = "kb"
MEDICAL_REPORTS_FOLDER = "medical_reports"
SYMPTOMS_FILE = "symptoms.json"
DIET_FILE = "diet.json"  # New diet JSON file
user_sessions = {}
user_report_states = {}  # Track users who are in report entry mode

# Ensure folders exist
for folder in [KB_FOLDER, MEDICAL_REPORTS_FOLDER]:
    if not os.path.exists(folder):
        os.makedirs(folder)

# Load symptoms data
def load_symptoms_data():
    """Load symptoms data from JSON file"""
    try:
        if os.path.exists(SYMPTOMS_FILE):
            with open(SYMPTOMS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        else:
            logging.warning(f"Symptoms file {SYMPTOMS_FILE} not found")
            return []
    except Exception as e:
        logging.error(f"Error loading symptoms data: {e}")
        return []

# Load diet data from JSON file
def load_diet_data():
    """Load diet and nutrition data from JSON file"""
    try:
        if os.path.exists(DIET_FILE):
            with open(DIET_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        else:
            logging.warning(f"Diet file {DIET_FILE} not found")
            return {}
    except Exception as e:
        logging.error(f"Error loading diet data: {e}")
        return {}

# Load data at startup
symptoms_data = load_symptoms_data()
diet_data = load_diet_data()
symptoms_keywords = {}

# Build symptom keywords for matching
if symptoms_data:
    for symptom in symptoms_data:
        name = symptom.get('name', '').lower()
        text = symptom.get('text', '').lower()
        alias = symptom.get('alias', '').lower()
        category = symptom.get('category', '').lower()
        
        # Extract keywords from various fields
        keywords = set()
        if name: keywords.add(name)
        if text: 
            # Extract main words from text
            words = text.replace('?', '').replace('.', '').split()
            for word in words:
                if len(word) > 3:  # Only meaningful words
                    keywords.add(word)
        if alias:
            for alias_word in alias.split(','):
                cleaned = alias_word.strip()
                if cleaned: keywords.add(cleaned)
        
        symptoms_keywords[symptom['name']] = {
            'symptom': symptom,
            'keywords': list(keywords)
        }

# User Profile Class
class UserProfile:
    def __init__(self, user_id, name, age=None, height=None, weight=None, medical_conditions=None):
        self.user_id = user_id
        self.name = name
        self.age = age
        self.height = height  # in cm
        self.weight = weight  # in kg
        self.medical_conditions = medical_conditions or []
        self.login_time = datetime.now()
    
    def to_dict(self):
        return {
            'user_id': self.user_id,
            'name': self.name,
            'age': self.age,
            'height': self.height,
            'weight': self.weight,
            'medical_conditions': self.medical_conditions,
            'login_time': self.login_time.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data):
        profile = cls(
            data['user_id'],
            data['name'],
            data.get('age'),
            data.get('height'),
            data.get('weight'),
            data.get('medical_conditions', [])
        )
        profile.login_time = datetime.fromisoformat(data['login_time'])
        return profile

# Medical Report Class
class MedicalReport:
    def __init__(self, user_id, report_name, report_type, date, doctor_name, findings, recommendations):
        self.user_id = user_id
        self.report_name = report_name
        self.report_type = report_type
        self.date = date
        self.doctor_name = doctor_name
        self.findings = findings
        self.recommendations = recommendations
        self.upload_time = datetime.now()
    
    def to_dict(self):
        return {
            'user_id': self.user_id,
            'report_name': self.report_name,
            'report_type': self.report_type,
            'date': self.date,
            'doctor_name': self.doctor_name,
            'findings': self.findings,
            'recommendations': self.recommendations,
            'upload_time': self.upload_time.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data):
        report = cls(
            data['user_id'],
            data['report_name'],
            data['report_type'],
            data['date'],
            data['doctor_name'],
            data['findings'],
            data['recommendations']
        )
        report.upload_time = datetime.fromisoformat(data['upload_time'])
        return report

# Enhanced local response database that uses diet.json
def get_nutrition_response(user_input, user_profile=None):
    """Get nutrition response from diet.json data"""
    user_input_lower = user_input.lower()
    
    # If diet.json is not loaded, use fallback
    if not diet_data:
        return get_fallback_nutrition_response(user_input_lower)
    
    # Check user goals first
    if 'user_goals' in diet_data:
        for goal_name, goal_data in diet_data['user_goals'].items():
            # Check if user mentions this goal
            goal_keywords = [goal_name.lower(), goal_data.get('description', '').lower()]
            if any(keyword in user_input_lower for keyword in goal_keywords if keyword):
                return format_goal_response(goal_name, goal_data, user_profile)
    
    # Check food database
    if 'food_database' in diet_data:
        for category, foods in diet_data['food_database'].items():
            for food in foods:
                food_name = food.get('name', '').lower()
                food_desc = food.get('description', '').lower()
                
                # Check if user mentions this food
                if food_name in user_input_lower:
                    return format_food_response(food, category, user_profile)
    
    # Check meal ideas
    if 'sample_meal_ideas' in diet_data:
        for meal_time, meals in diet_data['sample_meal_ideas'].items():
            if meal_time in user_input_lower:
                return format_meal_response(meal_time, meals, user_profile)
    
    # General nutrition principles
    nutrition_keywords = ['nutrition', 'diet', 'eat', 'food', 'meal', 'healthy', 'dietary']
    if any(keyword in user_input_lower for keyword in nutrition_keywords):
        return format_general_nutrition_response(user_profile)
    
    return None

def format_goal_response(goal_name, goal_data, user_profile):
    """Format response for specific goals"""
    response = f"ğŸ¯ **{goal_name.replace('_', ' ').title()} Advice**\n\n"
    
    if 'description' in goal_data:
        response += f"{goal_data['description']}\n\n"
    
    if 'key_principles' in goal_data:
        response += "**Key Principles:**\n"
        for i, principle in enumerate(goal_data['key_principles'][:5], 1):
            response += f"â€¢ {principle}\n"
    
    if user_profile:
        response += f"\nğŸ‘¤ *Personalized for {user_profile.name}:* "
        if goal_name == "weight_loss":
            bmi = calculate_bmi(user_profile.height, user_profile.weight)
            if bmi > 25:
                response += f"Your BMI is {bmi:.1f}. Focus on gradual, sustainable weight loss! âš–ï¸"
            else:
                response += "Maintain your healthy weight with balanced nutrition! ğŸ’ª"
        elif goal_name == "muscle_gain":
            response += "Ensure adequate protein intake for muscle recovery! ğŸ‹ï¸"
    
    if 'foods_to_prioritize' in goal_data and goal_data['foods_to_prioritize']:
        response += f"\n\nğŸ **Foods to focus on:** {', '.join(goal_data['foods_to_prioritize'][:5])}"
    
    return response

def format_food_response(food, category, user_profile):
    """Format response for specific foods"""
    response = f"ğŸ½ï¸ **{food['name'].replace('_', ' ').title()}** ({category.replace('_', ' ').title()})\n\n"
    response += f"{food.get('description', 'Nutritional information')}\n\n"
    
    # Add category-specific advice
    if category == 'proteins':
        response += "ğŸ’ª **Protein Power:** Great for muscle repair and satiety!\n"
    elif category == 'carbohydrates':
        response += "âš¡ **Energy Source:** Provides sustained energy throughout the day!\n"
    elif category == 'fats':
        response += "â¤ï¸ **Healthy Fats:** Essential for hormone production and nutrient absorption!\n"
    elif category == 'vegetables':
        response += "ğŸŒ± **Nutrient Rich:** Packed with vitamins, minerals, and fiber!\n"
    
    if user_profile:
        response += f"\nğŸ‘¤ *For {user_profile.name}:* "
        if category == 'proteins' and user_profile.age > 50:
            response += "Protein is especially important for maintaining muscle mass as you age!"
        elif category == 'carbohydrates' and user_profile.age < 25:
            response += "Carbs provide energy for your active lifestyle!"
    
    return response

def format_meal_response(meal_time, meals, user_profile):
    """Format response for meal times"""
    response = f"ğŸ´ **{meal_time.replace('_', ' ').title()} Ideas**\n\n"
    
    for i, meal in enumerate(meals[:3], 1):
        response += f"{i}. {meal}\n"
    
    if user_profile:
        response += f"\nğŸ‘¤ *For {user_profile.name}:* "
        if meal_time == 'breakfast':
            response += "Don't skip breakfast - it kickstarts your metabolism! ğŸŒ…"
        elif meal_time == 'dinner':
            response += "Try to have dinner at least 2-3 hours before bedtime! ğŸŒ™"
    
    return response

def format_general_nutrition_response(user_profile):
    """Format general nutrition advice"""
    response = "ğŸ¥— **General Nutrition Guidelines**\n\n"
    
    if 'general_nutrition_principles' in diet_data:
        for i, principle in enumerate(diet_data['general_nutrition_principles'][:5], 1):
            response += f"â€¢ {principle}\n"
    
    if user_profile:
        response += f"\nğŸ‘¤ *Personalized for {user_profile.name} ({user_profile.age}):* "
        if user_profile.age < 18:
            response += "Focus on balanced nutrition for growth and development! ğŸ“š"
        elif user_profile.age < 40:
            response += "Establish healthy eating habits for long-term wellness! ğŸ’ª"
        else:
            response += "Prioritize nutrient-dense foods for healthy aging! ğŸŒŸ"
    
    # Add food category suggestions
    if 'food_database' in diet_data:
        response += "\n\nğŸ·ï¸ **Food Categories Available:** "
        categories = list(diet_data['food_database'].keys())
        response += ", ".join([cat.replace('_', ' ').title() for cat in categories[:4]])
        response += "\n\nğŸ’¡ *Ask about specific foods or categories for detailed advice!*"
    
    return response

def get_fallback_nutrition_response(user_input_lower):
    """Fallback nutrition responses if diet.json is not available"""
    fallback_responses = {
        "burger": "ğŸ” Burgers are okay occasionally, but try adding veggies and choosing whole grain buns. Balance with salads!",
        "sweets": "ğŸ¬ Sweets in moderation! Try fruits for natural sweetness. Dark chocolate is a healthier option.",
        "diet": "A balanced diet includes proteins, veggies, fruits, and whole grains. Stay hydrated! ğŸ’§",
        "breakfast": "ğŸ¥£ Good breakfast options: oatmeal, eggs, yogurt with fruits, or whole grain toast.",
        "lunch": "ğŸ¥— Healthy lunch ideas: salads with protein, whole grain wraps, or vegetable soups.",
        "dinner": "ğŸ½ï¸ Light dinner options: grilled fish with veggies, stir-fries, or lentil stews.",
        "weight": "Maintain weight with balanced diet and regular exercise. Portion control is key! âš–ï¸",
        "protein": "ğŸ’ª Protein sources: chicken, fish, eggs, beans, tofu. Essential for muscle repair!",
        "carb": "âš¡ Healthy carbs: whole grains, fruits, vegetables. Provide sustained energy!",
        "fat": "â¤ï¸ Good fats: avocados, nuts, olive oil. Important for hormone production!",
        "vegetable": "ğŸŒ± Eat colorful vegetables! They're rich in vitamins, minerals, and fiber.",
        "fruit": "ğŸ Fruits provide natural sugars, fiber, and antioxidants. Enjoy in moderation!",
        "water": "ğŸ’§ Stay hydrated! Aim for 8 glasses of water daily. More if you're active!",
        "nutrition": "ğŸ¥— Focus on variety: different colored fruits/veggies, lean proteins, whole grains!",
        "default": "ğŸ For nutrition advice: focus on balanced meals, portion control, and hydration! Ask about specific foods or goals."
    }
    
    for keyword, response_text in fallback_responses.items():
        if keyword in user_input_lower:
            return response_text
    
    return fallback_responses["default"]

def calculate_bmi(height_cm, weight_kg):
    """Calculate BMI from height and weight"""
    try:
        height_m = int(height_cm) / 100
        weight = int(weight_kg)
        return weight / (height_m * height_m)
    except:
        return 0

# Enhanced local response system that uses diet.json
def get_local_response(intent, user_input, detected_symptoms=None, user_profile=None):
    """Get intelligent local responses based on keywords and symptoms"""
    user_input_lower = user_input.lower()
    
    # Handle symptoms with JSON data
    if intent == "symptoms" and detected_symptoms:
        response = "ğŸ¤’ **Detected Symptoms:**\n\n"
        for i, symptom in enumerate(detected_symptoms[:5], 1):  # Limit to 5 symptoms
            response += f"{i}. **{symptom['name']}**\n"
            response += f"   *{symptom['text'][:100]}...*\n"
            response += f"   Category: {symptom['category']}\n\n"
        
        response += "ğŸ’¡ *Note: This is informational only. Consult a healthcare professional for medical advice.*"
        return response
    
    # Handle nutrition with diet.json
    elif intent == "nutrition":
        nutrition_response = get_nutrition_response(user_input, user_profile)
        if nutrition_response:
            return nutrition_response
    
    # Handle stress management (keep existing)
    elif intent == "stress":
        stress_responses = {
            "stress": "ğŸ§˜ For stress: deep breathing, short walks, breaks, talk to someone.",
            "anxiety": "ğŸ˜Œ Anxiety? Try grounding techniques, focus on breathing, reduce caffeine.",
            "worry": "ğŸ¤” Worrying? Write thoughts down, focus on solutions, practice mindfulness.",
            "default": "ğŸ§  Mental health: regular exercise, good sleep, talk therapy helps. You're not alone!"
        }
        
        for keyword, response_text in stress_responses.items():
            if keyword in user_input_lower:
                return response_text
        return stress_responses["default"]
    
    # Fallback response
    return "I'm here to help with health questions! Try asking about nutrition, symptoms, or stress management. ğŸ¥"

# Intent detection (unchanged)
def detect_intent(text):
    """Detect user intent with better keyword matching"""
    text_lower = text.lower()
    
    nutrition_keywords = ['diet', 'nutrition', 'food', 'eat', 'meal', 'calorie', 'weight', 'breakfast', 'lunch', 'dinner', 'burger', 'sweets', 'chicken', 'rice', 'protein', 'carb', 'fat', 'vegetable', 'fruit', 'water', 'healthy', 'unhealthy']
    symptom_keywords = ['symptom', 'pain', 'fever', 'headache', 'hurt', 'unwell', 'sick', 'cough', 'fever', 'stomach', 'ache', 'blood pressure', 'heart rate', 'temperature']
    stress_keywords = ['stress', 'anxiety', 'worry', 'mental', 'mood', 'tension', 'relax']
    report_keywords = ['report', 'medical', 'test', 'lab', 'diagnosis', 'result', 'xray', 'blood', 'scan']
    
    # Enhanced symptom detection using JSON keywords
    if symptoms_keywords:
        for symptom_name, symptom_info in symptoms_keywords.items():
            for keyword in symptom_info['keywords']:
                if keyword in text_lower and len(keyword) > 3:
                    return "symptoms"
    
    if any(word in text_lower for word in nutrition_keywords):
        return "nutrition"
    elif any(word in text_lower for word in symptom_keywords):
        return "symptoms"
    elif any(word in text_lower for word in stress_keywords):
        return "stress"
    elif any(word in text_lower for word in report_keywords):
        return "medical_report"
    else:
        return "general"

# Enhanced symptom detection using JSON data
def detect_symptoms(user_input):
    """Detect specific symptoms from the JSON data"""
    user_input_lower = user_input.lower()
    detected_symptoms = []
    
    for symptom_name, symptom_info in symptoms_keywords.items():
        symptom_data = symptom_info['symptom']
        keywords = symptom_info['keywords']
        
        # Check if any keyword matches
        for keyword in keywords:
            if keyword in user_input_lower and len(keyword) > 3:
                detected_symptoms.append({
                    'name': symptom_data.get('name', 'Unknown'),
                    'text': symptom_data.get('laytext', symptom_data.get('text', '')),
                    'category': symptom_data.get('category', 'Unknown'),
                    'type': symptom_data.get('type', 'Unknown')
                })
                break  # Found this symptom, move to next
    
    return detected_symptoms

# Query Infermedica API for symptom analysis
def query_infermedica(symptoms_text):
    """Query Infermedica API for symptom analysis and treatment suggestions"""
    try:
        # Note: You'll need to sign up for Infermedica API and get your credentials
        # For now, this is a placeholder implementation
        app_id = "your_infermedica_app_id"  # Replace with your actual App ID
        app_key = "your_infermedica_app_key"  # Replace with your actual App Key
        
        if app_id == "your_infermedica_app_id" or app_key == "your_infermedica_app_key":
            # Fallback to local symptom database if Infermedica credentials not set
            return analyze_symptoms_locally(symptoms_text)
        
        url = "https://api.infermedica.com/v3/diagnosis"
        
        headers = {
            "App-Id": app_id,
            "App-Key": app_key,
            "Content-Type": "application/json"
        }
        
        payload = {
            "sex": "male",  # You might want to get this from user profile
            "age": 30,  # You might want to get this from user profile
            "evidence": [],  # This would be populated with symptoms
            "extras": {
                "disable_groups": True
            }
        }
        
        # For now, return a placeholder response
        return "ğŸ” **Symptom Analysis**\n\nBased on your symptoms, I recommend:\n\nâ€¢ Rest and hydration\nâ€¢ Monitor your symptoms\nâ€¢ Consult a healthcare professional if symptoms persist\n\n*Note: For accurate medical advice, please consult a doctor.*"
    
    except Exception as e:
        logging.error(f"Error querying Infermedica: {e}")
        return analyze_symptoms_locally(symptoms_text)

def analyze_symptoms_locally(symptoms_text):
    """Fallback local symptom analysis using the symptoms database"""
    detected_symptoms = detect_symptoms(symptoms_text)
    
    if not detected_symptoms:
        return "I couldn't identify specific symptoms in your message. Please describe your symptoms in more detail."
    
    response = "ğŸ” **Symptom Analysis**\n\nBased on your description, I detected these symptoms:\n\n"
    
    for i, symptom in enumerate(detected_symptoms[:5], 1):
        response += f"**{symptom['name']}**\n"
        response += f"â€¢ Category: {symptom['category']}\n"
        response += f"â€¢ Description: {symptom['text'][:150]}...\n\n"
    
    response += "ğŸ’¡ **General Advice:**\n"
    response += "â€¢ Rest and stay hydrated\n"
    response += "â€¢ Monitor your symptoms\n"
    response += "â€¢ Seek medical attention if symptoms worsen\n"
    response += "â€¢ Avoid self-medication without professional advice\n\n"
    response += "âš ï¸ *This is not medical advice. Please consult a healthcare professional.*"
    
    return response

# Save user report content to KB folder
def save_user_report_content(user_id, content):
    """Save user's medical report content to their KB file"""
    try:
        user_kb_file = os.path.join(KB_FOLDER, f"user_{user_id}_reports.txt")
        
        with open(user_kb_file, 'a', encoding='utf-8') as f:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            f.write(f"\n\n--- Medical Report Entry [{timestamp}] ---\n")
            f.write(content)
            f.write("\n--- End of Entry ---\n")
        
        return True
    except Exception as e:
        logging.error(f"Error saving user report content: {e}")
        return False

# Main query function - UPDATED to use diet.json and Infermedica
def generate_response(user_input, user_id):
    """Generate response with smart fallback system"""
    intent = detect_intent(user_input)
    detected_symptoms = detect_symptoms(user_input) if intent == "symptoms" else None
    
    logging.info(f"Detected intent: {intent}, Symptoms found: {len(detected_symptoms) if detected_symptoms else 0}")
    
    # Check if user is in report entry mode
    if user_id in user_report_states and user_report_states[user_id]:
        # Save the content to user's KB file
        save_user_report_content(user_id, user_input)
        return "ğŸ“ Added to your medical report. Continue typing or use /stop to finish."
    
    # Handle medical report intent specifically
    if intent == "medical_report":
        if user_id in user_sessions:
            return "ğŸ“‹ I see you're asking about medical reports. Use /medicalreport to manage your reports!"
        else:
            return "ğŸ“‹ Please /login first to access your medical reports!"
    
    # Get user profile for personalization
    user_profile = user_sessions.get(user_id)
    
    # Handle symptom analysis with Infermedica
    if intent == "symptoms" and detected_symptoms:
        symptoms_text = " ".join([symptom['name'] for symptom in detected_symptoms])
        infermedica_response = query_infermedica(symptoms_text)
        return infermedica_response
    
    # Use diet.json for nutrition queries (skip Gemini)
    if intent == "nutrition":
        nutrition_response = get_nutrition_response(user_input, user_profile)
        if nutrition_response:
            return nutrition_response
    
    # For other intents, try Gemini API
    gemini_response = query_gemini(user_input)
    if gemini_response:
        return f"ğŸ¤– {gemini_response}"
    
    # Use local responses as fallback
    local_response = get_local_response(intent, user_input, detected_symptoms, user_profile)
    
    return local_response

# Test Gemini API connection
def test_gemini_connection():
    """Test if Gemini API is working"""
    try:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key={GEMINI_API_KEY}"
        
        payload = {
            "contents": [{
                "parts": [{"text": "Say 'Hello' in one word"}]
            }]
        }
        
        response = requests.post(url, json=payload, timeout=5)
        return response.status_code == 200
    except:
        return False

# Improved Gemini API function
def query_gemini(user_input, context=""):
    """Query Gemini API with multiple fallback strategies"""
    if not test_gemini_connection():
        return None
    
    try:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key={GEMINI_API_KEY}"
        
        prompt = f"Provide brief health advice for: '{user_input}'. Keep response under 150 characters."
        
        payload = {
            "contents": [{
                "parts": [{"text": prompt}]
            }],
            "generationConfig": {
                "maxOutputTokens": 150,
                "temperature": 0.3
            }
        }
        
        response = requests.post(url, json=payload, timeout=8)
        
        if response.status_code == 200:
            data = response.json()
            if 'candidates' in data and data['candidates']:
                return data['candidates'][0]['content']['parts'][0]['text']
        
        return None
        
    except:
        return None

# Medical Report Management Functions
def save_medical_report(report):
    """Save medical report to file"""
    try:
        user_folder = os.path.join(MEDICAL_REPORTS_FOLDER, str(report.user_id))
        if not os.path.exists(user_folder):
            os.makedirs(user_folder)
        
        filename = f"{report.report_name.replace(' ', '_')}_{report.upload_time.strftime('%Y%m%d_%H%M%S')}.json"
        filepath = os.path.join(user_folder, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(report.to_dict(), f, indent=2, ensure_ascii=False)
        
        return True
    except Exception as e:
        logging.error(f"Error saving medical report: {e}")
        return False

def load_medical_reports(user_id):
    """Load all medical reports for a user"""
    try:
        user_folder = os.path.join(MEDICAL_REPORTS_FOLDER, str(user_id))
        if not os.path.exists(user_folder):
            return []
        
        reports = []
        for filename in os.listdir(user_folder):
            if filename.endswith('.json'):
                filepath = os.path.join(user_folder, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    report_data = json.load(f)
                    reports.append(MedicalReport.from_dict(report_data))
        
        return sorted(reports, key=lambda x: x.upload_time, reverse=True)
    except Exception as e:
        logging.error(f"Error loading medical reports: {e}")
        return []

# Telegram Command Handlers
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send welcome message when the command /start is issued."""
    welcome_text = """
ğŸ‘‹ Welcome to Health Assistant Bot!

I can help you with:
â€¢ ğŸ¥— Nutrition and diet advice
â€¢ ğŸ¤’ Symptom information
â€¢ ğŸ§˜ Stress management tips
â€¢ ğŸ“‹ Medical report tracking

Available commands:
/register - Create your profile
/login - Login to your account
/profile - View your profile
/medicalreport - Manage medical reports

Just ask me any health-related question!
"""
    await update.message.reply_text(welcome_text)

async def register(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Register a new user"""
    user_id = update.effective_user.id
    
    if user_id in user_sessions:
        await update.message.reply_text("âœ… You're already registered and logged in!")
        return
    
    # Simple registration - just create a basic profile
    user_profile = UserProfile(
        user_id=user_id,
        name=update.effective_user.first_name or "User"
    )
    
    user_sessions[user_id] = user_profile
    
    await update.message.reply_text(
        f"âœ… Registration successful! Welcome {user_profile.name}!\n\n"
        "You can now use /medicalreport to manage your medical reports."
    )

async def login(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Login user"""
    user_id = update.effective_user.id
    
    if user_id in user_sessions:
        await update.message.reply_text("âœ… You're already logged in!")
        return
    
    # For now, just create a basic profile (same as register)
    user_profile = UserProfile(
        user_id=user_id,
        name=update.effective_user.first_name or "User"
    )
    
    user_sessions[user_id] = user_profile
    
    await update.message.reply_text(
        f"âœ… Login successful! Welcome back {user_profile.name}!\n\n"
        "You can now use /medicalreport to manage your medical reports."
    )

async def profile(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show user profile"""
    user_id = update.effective_user.id
    
    if user_id not in user_sessions:
        await update.message.reply_text("âŒ Please /login first to view your profile!")
        return
    
    profile = user_sessions[user_id]
    
    profile_text = f"ğŸ‘¤ **User Profile**\n\n"
    profile_text += f"**Name:** {profile.name}\n"
    profile_text += f"**User ID:** {profile.user_id}\n"
    profile_text += f"**Age:** {profile.age if profile.age else 'Not set'}\n"
    profile_text += f"**Height:** {profile.height if profile.height else 'Not set'} cm\n"
    profile_text += f"**Weight:** {profile.weight if profile.weight else 'Not set'} kg\n"
    
    if profile.age and profile.height and profile.weight:
        bmi = calculate_bmi(profile.height, profile.weight)
        profile_text += f"**BMI:** {bmi:.1f}\n"
    
    profile_text += f"**Medical Conditions:** {', '.join(profile.medical_conditions) if profile.medical_conditions else 'None'}\n"
    profile_text += f"**Login Time:** {profile.login_time.strftime('%Y-%m-%d %H:%M')}\n"
    
    await update.message.reply_text(profile_text)

async def medicalreport(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manage medical reports - start report entry mode"""
    user_id = update.effective_user.id
    
    if user_id not in user_sessions:
        await update.message.reply_text("âŒ Please /login first to access medical reports!")
        return
    
    # Start report entry mode
    user_report_states[user_id] = True
    
    await update.message.reply_text(
        "ğŸ“ **Medical Report Entry Mode**\n\n"
        "I'm now listening for your medical report content. Please type your report information.\n\n"
        "You can include:\n"
        "â€¢ Symptoms you're experiencing\n"
        "â€¢ Test results\n"
        "â€¢ Doctor's notes\n"
        "â€¢ Medications\n"
        "â€¢ Any other relevant health information\n\n"
        "Type /stop when you're finished to save your report."
    )

async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Stop medical report entry mode"""
    user_id = update.effective_user.id
    
    if user_id in user_report_states and user_report_states[user_id]:
        user_report_states[user_id] = False
        await update.message.reply_text(
            "âœ… Medical report entry stopped. Your information has been saved to your knowledge base.\n\n"
            "Use /medicalreport to start a new report entry session."
        )
    else:
        await update.message.reply_text("âŒ You're not currently in report entry mode.")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle incoming messages"""
    user_input = update.message.text
    user_id = update.effective_user.id
    
    logging.info(f"User {user_id}: {user_input}")
    
    # Check if user is in report entry mode
    if user_id in user_report_states and user_report_states[user_id]:
        # Save content and provide feedback without generating a response
        save_user_report_content(user_id, user_input)
        await update.message.reply_text("ğŸ“ Added to your medical report. Continue typing or use /stop to finish.")
        return
    
    # Generate response for normal messages
    response = generate_response(user_input, user_id)
    
    # Send response
    await update.message.reply_text(response)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Log errors"""
    logging.error(f"Update {update} caused error {context.error}")

# Update the main function to show diet.json status
def main():
    # Test connections at startup
    gemini_working = test_gemini_connection()
    symptoms_loaded = len(symptoms_data) > 0
    diet_loaded = len(diet_data) > 0 if diet_data else False
    
    print("=" * 60)
    print("ğŸ¥ Health Assistant Bot Starting...")
    print("ğŸ“± Telegram Token: Ready")
    print(f"ğŸ¤– Gemini API: {'Connected' if gemini_working else 'Local Mode'}")
    print(f"ğŸ“Š Symptoms Database: {len(symptoms_data)} entries loaded")
    print(f"ğŸ¥— Diet Database: {'Loaded' if diet_loaded else 'Not found'}")
    print("ğŸ‘¤ Login System: Ready")
    print("ğŸ“‹ Medical Reports System: Ready")
    print("ğŸ’¡ Infermedica Integration: Ready (with fallback)")
    print("=" * 60)
    print("âœ… Bot is now running! Press Ctrl+C to stop.")
    
    if diet_loaded:
        print("ğŸ¥— Diet features available! Try: 'weight loss tips', 'protein foods', 'breakfast ideas'")
    else:
        print("âš ï¸ diet.json not found - using fallback nutrition responses")
    
    print("ğŸ‘‰ Try: /medicalreport to enter medical report mode")
    print("ğŸ‘‰ Try: /stop to exit medical report mode")
    print("=" * 60)
    
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    
    # Command handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("register", register))
    app.add_handler(CommandHandler("login", login))
    app.add_handler(CommandHandler("profile", profile))
    app.add_handler(CommandHandler("medicalreport", medicalreport))
    app.add_handler(CommandHandler("stop", stop))
    
    # Message handler
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Error handler
    app.add_error_handler(error_handler)
    
    app.run_polling()

if __name__ == "__main__":
    main()
